# 父子组件通讯

## 父传子

父传子，依旧需要在子组件标签中绑定属性进行props的传递，子组件也依然要通过配置props选项来进行接收，最关键的是如何在setup中进行访问。

之前我们了解过setup接收两个参数

* props
* context

没错，就是通过props参数访问父组件传入的数据，但在使用时，有一些注意点：

* 由于props是一个Proxy对象，所以不能直接进行解构。
  * 可以使用toRefs转化后进行逐一解构。
* 禁止在子组件中更改父组件传入的props，因为如果props中的状态是`引用类型数据`，则会直接影响父组件以及其它依赖该props的子组件。

这里用一个简单的案例来加深印象

**App.vue**

```
<template>
  <main>
    <h2>{{ title }}</h2>
    <Child :list="list" />
  </main>
</template>
<script>
  import { defineComponent, reactive, toRefs } from "vue";
  import Child from "./Child.vue";
  export default defineComponent({
    components: {
      Child,
    },
    setup() {
      const state = reactive({
        title: "App",
        list: ["新闻", "娱乐", "科技"],
      });

      return {
        ...toRefs(state),
      };
    },
  });
</script>
```

**Child.vue**

```
<template>
  <div>
    <h3>{{ title }}</h3>
    <hr />
    <p>父组件传入的props</p>
    <ul>
      <li v-for="val in parent.list" :key="val">{{ val }}</li>
    </ul>
  </div>
</template>
<script>
  import { defineComponent, reactive, toRefs } from "vue";

  export default defineComponent({
    props: {
      list: {
        type: Array,
        default: () => [],
      },
    },
    setup(props) {
      const state = reactive({
        title: "我是child组件",
      });
      console.log(props);
      /*
        由于props是一个Proxy对象，所以不能直接进行解构，
        可以使用toRefs转化后进行逐一解构。
      */
      // let { list } = props;
      let { list } = toRefs(props);

      console.log(list.value);
      const parent = {
        list: list.value,
      };

      return {
        ...toRefs(state),
        parent,
      };
    },
  });
</script>
```

## 子传父

在Vue2.x中我们需要通过`this.$emit`完成子传父，但Vue3中的`setup`不能访问`this`，那要怎么实现呢？

* 通过setup的第二个参数`context`进行访问。

  * **context包含哪些可访问选项呢？**

    执行 `setup` 时，组件实例尚未被创建。因此，你只能访问以下 property：

    - `props`
    - `attrs`
    - `slots`
    - `emit`

    换句话说，你**将无法访问**以下组件选项：

    - `data`
    - `computed`
    - `methods`

* 由于context数据不是响应式的，所以可以解构想要使用的功能函数。

这里用一个简单的案例来加深印象👇

**App.vue**

```
<template>
  <main>
    <h2>{{ title }}</h2>
    <Child v-show="isShow" @hidden="hiddenChild" />
  </main>
</template>
<script>
  import { defineComponent, reactive, toRefs } from "vue";
  import Child from "./Child.vue";
  export default defineComponent({
    components: {
      Child,
    },
    setup() {
      const state = reactive({
        title: "App",
        isShow: true,
      });

      const hiddenChild = (isShow) => {
        state.isShow = isShow;
      };
      return {
        ...toRefs(state),
        hiddenChild,
      };
    },
  });
</script>
```

**Child.vue**

```
<template>
  <div>
    <h3>{{ title }}</h3>
    <hr />
    <button @click="hidden">点我隐藏</button>
  </div>
</template>
<script>
  import { defineComponent, reactive, toRefs } from "vue";

  export default defineComponent({
    setup(props, { emit }) {
      const state = reactive({
        title: "我是child组件",
      });

      const hidden = () => {
        emit("hidden", false);
      };
      return {
        ...toRefs(state),
        hidden,
      };
    },
  });
</script>
```

# provide&inject

前面讲到了父子组件的通讯，但如果component层级嵌套很深，就意味着要逐层进行state的传递，这会有一些不好的影响：

* 实现过程繁琐。
* 还会导致中间组件被迫接收state
* 代码臃肿

我们可以使用`provide`、`inject`进行解决，其主要使用思路为：

* `provide`、`inject`二者都是vue中的功能函数，使用前要先进行导入。

* `provide`可以将父组件中的状态共享给后代组件，该状态可以是普通变量、方法。
* 后代组件通过`inject`将`provide`共享的状态注入。

### provide

```
provide("stateName",state)
```

* stateName
  * 定义共享状态的名称，后代组件就是通过该名称访问对应的状态
* state
  * 要共享的state，可以是普通变量，也可是方法。

### inject

```
const state = inject("stateName",defaultValue)
```

* 传入stateName即可访问对应的共享状态，可通过第二个可选参数定义默认值。
* 这些共享状态是**只读的**，如果尝试更改，会报错。

### 案例体验

共有三个组件，其嵌套关系为：

* App
  * Child
    * Grandson

通过`provide&inject`让App与Grandson直接通讯，当在Grandson中点击按钮时，通过App的事件让Child隐藏。

**App.vue**

```
<template>
  <main>
    <h2>{{ title }}</h2>
    <Child v-show="isShow" />
  </main>
</template>
<script>
  import { defineComponent, reactive, toRefs, provide } from "vue";
  import Child from "./Child.vue";

  export default defineComponent({
    components: {
      Child,
    },
    setup() {
      const state = reactive({
        title: "App",
        isShow: true,
      });

      const changeIsShow = (isShow) => {
        console.log(isShow);
        state.isShow = isShow;
      };
      //共享状态
      provide("changeIsShow", changeIsShow);
      provide("title", state.title);
      return {
        ...toRefs(state),
      };
    },
  });
</script>
<style scoped>
  main {
    background: pink;
  }
</style>
```

**Child.vue**

```
<template>
  <div>
    <h3>{{ title }}</h3>
    <hr />
    <grandson />
  </div>
</template>
<script>
  import { defineComponent, reactive, toRefs } from "vue";
  import Grandson from "./Grandson.vue";
  export default defineComponent({
    components: {
      Grandson,
    },
    setup(props, { emit }) {
      const state = reactive({
        title: "我是child组件",
      });

      return {
        ...toRefs(state),
      };
    },
  });
</script>
<style scoped>
  div {
    background: yellowgreen;
  }
</style>
```

**Grandson.vue**

```
<template>
  <div id="Grandson">
    <h3>{{ title }}</h3>
    <hr />
    <button @click="hidden">点我隐藏</button>
  </div>
</template>
<script>
  import { defineComponent, reactive, toRefs, inject } from "vue";

  export default defineComponent({
    setup(props) {
      const state = reactive({
        title: "我是Grandson组件",
      });
			//注入共享变量
      const hidden = inject("changeIsShow").bind(null,false);
      //打印结果可知，就是App组件共享的函数
      console.log(hidden);
      
      return {
        ...toRefs(state),
        hidden,
      };
    },
  });
</script>
<style scoped>
  #Grandson {
    background: #e67e22;
    margin: 5px;
  }
</style>
```

### 使用注意项

`provide&inject`在使用时有一些注意项，这里先汇总一下：

1. `provide`共享的状态是**只读的**，如果后代组件使用`inject`接收后进行更改会报错。
2. 两者都**只能**在当前活动实例的 `setup()` 期间调用

---

**解析1** 

​	拿上文案例来说，在后代组件定义`hidden`变量，接收`changeIsShow`共享方法。但如果在后期对hidden进行更改，会报错，告知你这些状态是`readonly`。

**解析2**

​	`provide&inject`**只能**在当前活动实例的 `setup()` 期间调用。

这个特点很重要，例如：在后代组件点击按钮后，除了执行共享方法`changeIsShow`，我还想进行一些操作用于维护该后代组件，此时你可能会写出下例代码：

```
const hidden = () => {
	//共享方法执行
  inject("changeIsShow").call(null, false);
  //其他操作
  ……
};
```

但很遗憾，这种操作不能奏效，原因就是`provide&inject`**只能**在当前活动实例的 `setup()` 期间调用。将其封装到事件中也不可以，因为当与视图交互触发该事件时，已经是挂载后了。

不过我们可以将其他操作部分抽离到另一个函数中，然后侦听多个`click`事件即可。

* 各个事件必须是**函数调用形式**，这就意味着**参数传递**要在template中完成。
* 各个事件之间使用 `;` 隔开。

```
<template>
……
    <button
      @click="
        hidden(false);
        testEvent();
      "
    >
      点我隐藏
    </button>
……
</template>
<script>
  import { defineComponent, reactive, toRefs, inject } from "vue";

  export default defineComponent({
    setup(props, { emit }) {
      const state = reactive({
        title: "我是Grandson组件",
      });

      const hidden = inject("changeIsShow");
      const title = inject("title", "Ashuntefannao");

      const testEvent = () => {
        console.log(title);
      };

      return {
        ...toRefs(state),
        hidden,
        testEvent,
      };
    },
  });
</script>
```

可以看到，当业务比较复杂时，`provide&inject`使用过程也比较复杂。当然你可以使用`Vuex`，也可使用下文讲解到的`mitt`插件，实现Vue2.x中的事件总线。

# tiny-emitter/mitt实现事件总线

在Vue2.x中我们如果要实现一个事件总线非常简单：

```
import Vue from "vue"
Vue.prototype.$bus = new Vue();
```

后期在组件中使用`$on、$emit`进行事件的侦听和发射。

但在Vue3中，不能直接像Vue2.x一样简单的实现，原因有两个：

1. `setup`中不能访问`this`

2. 实例中完全移除了 `$on`、`$off` 和 `$once` 方法。

   通过Vue3的`createApp`创建实例，打印结果也可看到，移除了上述API

   `$emit` 仍然包含于现有的 API 中，因为它用于触发由父组件声明式添加的事件处理函数。

---

Event bus 模式可以被替换为实现了事件触发器接口的外部库，例如 [mitt](https://github.com/developit/mitt) 或 [tiny-emitter](https://github.com/scottcorgan/tiny-emitter)。

示例:

```
tiny-emitter
```

```
// eventBus.js
import emitter from 'tiny-emitter/instance'

export default {
  $on: (...args) => emitter.on(...args),
  $once: (...args) => emitter.once(...args),
  $off: (...args) => emitter.off(...args),
  $emit: (...args) => emitter.emit(...args),
}
```

它提供了与 Vue 2 相同的事件触发器 API。

当然，我们也可以使用[mitt](https://github.com/developit/mitt)，只不过其提供的API没有完全与Vue2.x保持一致：

- mitt
- all
- on
- off
- emit

